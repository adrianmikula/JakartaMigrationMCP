# Migration Phase Definitions
# Format: phase.{strategy}.{phaseNumber}.title=Title
#         phase.{strategy}.{phaseNumber}.description=Description
#         phase.{strategy}.{phaseNumber}.steps=Step1\nStep2\nStep3

# ============================================
# BIG BANG Strategy Phases
# ============================================

phase.big_bang.1.title=Complete Migration
phase.big_bang.1.description=The Big Bang migration approach involves migrating all javax dependencies to Jakarta EE in a single, comprehensive pass. This strategy is best suited for small to medium-sized projects that are relatively self-contained and have comprehensive test coverage. The main advantage is speed - you complete the migration in one go, but this also means all your eggs are in one basket. You'll need to thoroughly plan the migration, ensure you have a complete backup of your codebase, and be prepared for a potentially longer rollback time if issues arise. This approach requires comprehensive testing before starting and may cause extended downtime during the migration process.\n\nKey activities include updating all dependency declarations in your build files (pom.xml, build.gradle, etc.), systematically replacing all javax.* imports with jakarta.* across every Java source file, updating XML configuration files that reference javax, updating property files and resource bundles, and running your complete suite of unit and integration tests to verify everything works correctly.
phase.big_bang.1.steps=Update build files (pom.xml, build.gradle)\nReplace javax.* imports globally\nUpdate XML configuration files\nUpdate property files and resource bundles\nRun comprehensive test suite

# ============================================
# INCREMENTAL Strategy Phases
# ============================================

phase.incremental.1.title=Dependency Updates
phase.incremental.1.description=The Incremental migration approach updates dependencies one at a time, starting with the lowest-risk ones and progressing to higher-risk dependencies. This strategy is ideal for large, complex projects where a big-bang approach would be too risky. By migrating incrementally, you can identify and fix issues as they arise, rather than dealing with a massive cascade of failures.\n\nStart by analyzing your current dependency tree to understand which dependencies need to be migrated. Focus on transitive dependencies first (those that are dependencies of your dependencies), then move to direct dependencies. For each dependency, check if there's a Jakarta EE equivalent available. Update the lowest-risk dependencies first - typically those with few dependents and good test coverage. After each update, verify there are no breaking changes before proceeding to the next dependency.
phase.incremental.1.steps=Analyze dependency tree\nIdentify Jakarta equivalents\nUpdate transitive dependencies first\nUpdate direct dependencies\nVerify after each update

phase.incremental.2.title=Import Replacement
phase.incremental.2.description=Once your dependencies have been updated to use Jakarta EE, the next step is to systematically replace all javax.* imports with jakarta.* imports across your entire codebase. This is where the bulk of the work happens. Use your IDE's refactoring tools to perform safe, global replacements.\n\nStart with transitive dependencies (libraries you've pulled in), then direct dependencies, then your application code. Be careful with reflection-based code and configuration files that may contain class names or package references. You'll also need to update any XML configuration files, deployment descriptors, and property files that reference the old javax namespaces. Consider using OpenRewrite recipes to automate much of this work.
phase.incremental.2.steps=Replace transitive dependency imports\nReplace direct dependency imports\nReplace application code imports\nUpdate XML configuration files\nUpdate property files

phase.incremental.3.title=Testing & Verification
phase.incremental.3.description=After completing the import replacements, comprehensive testing is essential to ensure everything works correctly. This phase involves running your full test suite to catch any issues that may have been introduced during the migration.\n\nRun all unit tests first to verify individual components work correctly. Then run integration tests to ensure different parts of your application work together properly. Pay special attention to testing code that interacts with external systems, databases, or uses reflection. Verify that error handling still works correctly and that any custom exception handling is still functional. Don't forget to test any scheduled jobs, message consumers, and event handlers.
phase.incremental.3.steps=Run unit tests\nRun integration tests\nTest external system interactions\nTest database operations\nTest scheduled jobs and events

phase.incremental.4.title=Production Rollout
phase.incremental.4.description=The final phase involves deploying your migrated application to production. This requires careful planning and monitoring to ensure a smooth transition.\n\nStart by deploying to a staging environment that mirrors production as closely as possible. Monitor performance metrics closely during this phase - look for any degradation in response times, increased error rates, or unusual behavior. Once you're confident the application is working correctly in staging, deploy to production. Continue monitoring closely after the production deployment and have a rollback plan ready in case critical issues arise.
phase.incremental.4.steps=Deploy to staging environment\nMonitor performance metrics\nDeploy to production\nMonitor production closely\nHave rollback plan ready

# ============================================
# TRANSFORM Strategy Phases
# ============================================

phase.transform.1.title=Build Tool Updates
phase.transform.1.description=Update build configuration to use Jakarta EE dependencies. This involves modifying pom.xml or build.gradle files to use Jakarta EE compatible versions of your dependencies while maintaining javax compatibility for the initial phase.
phase.transform.1.steps=Add Jakarta EE BOM to dependencyManagement\nUpdate artifact coordinates\nConfigure Jakarta EE version\nVerify build compiles

phase.transform.2.title=Runtime Transformation Setup
phase.transform.2.description=Configure runtime transformation for javax to jakarta conversion. This allows your application to work with both javax and jakarta simultaneously during the transition period. Options include Eclipse Transformer or custom class loading.
phase.transform.2.steps=Install Eclipse Transformer\nConfigure transformation rules\nTest transformation pipeline\nVerify runtime behavior

phase.transform.3.title=Gradual Migration
phase.transform.3.description=Migrate code gradually while maintaining backward compatibility. Migrate one module at a time, testing thoroughly after each migration to ensure everything continues to work.
phase.transform.3.steps=Migrate lowest-risk module first\nTest module in isolation\nRepeat for each module\nVerify cross-module compatibility

phase.transform.4.title=Complete Migration
phase.transform.4.description=Complete the migration by removing runtime transformation. Once all code has been migrated to Jakarta EE, remove the transformation layer and deploy the fully migrated application.
phase.transform.4.steps=Remove transformation configuration\nVerify all tests pass\nDeploy fully migrated application

# ============================================
# MICROSERVICES Strategy Phases (FIXED)
# ============================================

phase.microservices.1.title=Service Inventory
phase.microservices.1.description=Create a comprehensive inventory of all microservices in your architecture. Identify each service, its dependencies, and the javax usage within each. This helps plan the migration order and understand inter-service dependencies.
phase.microservices.1.steps=List all microservices\nMap service dependencies\nIdentify javax usage per service\nPlan migration order

phase.microservices.2.title=Shared Libraries Migration
phase.microservices.2.description=Migrate shared libraries and common code first, before individual services. This ensures all services have access to the updated Jakarta EE versions of shared components.
phase.microservices.2.steps=Identify shared libraries\nMigrate shared code to Jakarta EE\nUpdate service dependencies\nVerify library compatibility

phase.microservices.3.title=Service-by-Service Migration
phase.microservices.3.description=Migrate each service individually, starting with the least critical services. Each service can use a different migration strategy based on its specific needs. Independent deployment and testing ensures minimal impact on the overall system.
phase.microservices.3.steps=Migrate least critical service first\nTest service in isolation\nUpdate service dependencies\nRepeat for remaining services

phase.microservices.4.title=Integration Testing
phase.microservices.4.description=After migrating individual services, perform comprehensive integration testing to ensure all services work correctly together. Test inter-service communication, data consistency, and overall system behavior.
phase.microservices.4.steps=Test inter-service communication\nVerify data consistency\nTest end-to-end scenarios\nDeploy to production

# ============================================
# ADAPTER PATTERN Strategy Phases (NEW)
# ============================================

phase.adapter.1.title=Adapter Interface Design
phase.adapter.1.description=Design and create adapter interfaces that wrap javax functionality with jakarta implementations underneath. This allows your code to gradually migrate from javax to jakarta while maintaining the same external API.
phase.adapter.1.steps=Identify interfaces needing adapters\nDesign adapter interfaces\nCreate jakarta implementations\nTest adapter functionality

phase.adapter.2.title=Adapter Implementation
phase.adapter.2.description=Implement the adapter classes that translate between javax and jakarta. These adapters will be used internally while the external API remains unchanged.
phase.adapter.2.steps=Implement javax adapter wrapper\nImplement jakarta underlying classes\nConfigure adapter instantiation\nTest adapter integration

phase.adapter.3.title=Gradual Replacement
phase.adapter.3.description=Gradually replace usages of the adapter with direct jakarta calls. Start with the least critical paths and work towards more heavily used code.
phase.adapter.3.steps=Replace least critical usage first\nTest after each replacement\nProgress to more critical paths\nVerify performance impact

phase.adapter.4.title=Remove Adapters
phase.adapter.4.description=Once all code has been migrated to use jakarta directly, remove the adapter layer and clean up any remaining javax dependencies.
phase.adapter.4.steps=Verify all jakarta usage\nRemove adapter layer\nClean up javax dependencies\nDeploy final version
