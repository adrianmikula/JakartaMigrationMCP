# ============================================================================
# UI Text Descriptions Property File
# Central location for all long-form text content in the plugin UI
# This allows for easy localization and text management
# ============================================================================

# ============================================
# MIGRATION STRATEGY - BENEFITS
# ============================================

# Big Bang Strategy Benefits
strategy.big_bang.benefits=• Migrate all javax dependencies to Jakarta EE at once\n• Single comprehensive change\n• Best for small, self-contained projects\n• Requires thorough testing before starting

# Incremental Strategy Benefits
strategy.incremental.benefits=• Migrate dependencies incrementally\n• Update one dependency, test, then proceed\n• Lower risk per change\n• Best for large, complex projects

# Transform Strategy Benefits
strategy.transform.benefits=• Combine build-time and runtime transformation approaches\n• Use OpenRewrite for automated code changes\n• Deploy runtime adapters for edge cases\n• Best for complex enterprise applications

# Microservices Strategy Benefits
strategy.microservices.benefits=• Migrate microservices one at a time\n• Each service can use different strategy\n• Independent deployment and testing\n• Best for distributed architectures

# Adapter Pattern Strategy Benefits
strategy.adapter.benefits=• Maintain backward compatibility during migration\n• Gradual replacement of javax with jakarta\n• Lower risk changes\n• Easy to rollback individual adapters

# ============================================
# MIGRATION STRATEGY - RISKS
# ============================================

# Big Bang Strategy Risks
strategy.big_bang.risks=• Higher risk - issues affect entire codebase\n• Longer rollback time if problems occur\n• Requires comprehensive test suite\n• May cause extended downtime during migration

# Incremental Strategy Risks
strategy.incremental.risks=• Longer overall migration timeline\n• Must maintain compatibility during transition\n• May require temporary dual dependencies\n• Need careful dependency ordering

# Transform Strategy Risks
strategy.transform.risks=• Most complex implementation\n• Requires both build and runtime configuration\n• Higher resource overhead\n• May need specialized expertise

# Microservices Strategy Risks
strategy.microservices.risks=• Requires coordination across services\n• Inter-service dependencies must be handled\n• May need service mesh updates\n• Longer overall migration timeline

# Adapter Pattern Strategy Risks
strategy.adapter.risks=• Additional code maintenance\n• Runtime overhead for adapter layer\n• More complex classpath management\n• Need to track adapter usage

# ============================================
# MIGRATION STRATEGY - PHASE DESCRIPTIONS
# ============================================

# --- Big Bang Strategy Phases ---

# Phase 1: Complete Migration
phase.big_bang.1.title=Complete Migration
phase.big_bang.1.description=The Big Bang migration approach involves migrating all javax dependencies to Jakarta EE in a single, comprehensive pass. This strategy is best suited for small to medium-sized projects that are relatively self-contained and have comprehensive test coverage. The main advantage is speed - you complete the migration in one go, but this also means all your eggs are in one basket. You'll need to thoroughly plan the migration, ensure you have a complete backup of your codebase, and be prepared for a potentially longer rollback time if issues arise. This approach requires comprehensive testing before starting and may cause extended downtime during migration.
phase.big_bang.1.steps=Update build files (pom.xml, build.gradle)\nReplace javax.* imports globally\nUpdate XML configuration files\nUpdate property files and resource bundles\nRun comprehensive test suite

# --- Incremental Strategy Phases ---

# Phase 1: Dependency Updates
phase.incremental.1.title=Dependency Updates
phase.incremental.1.description=The Incremental migration approach updates dependencies one at a time, starting with the lowest-risk ones and progressing to higher-risk dependencies. This strategy is ideal for large, complex projects where a big-bang approach would be too risky. By migrating incrementally, you can identify and fix issues as they arise, rather than dealing with a massive cascade of failures.
phase.incremental.1.steps=Analyze dependency tree\nIdentify Jakarta equivalents\nUpdate transitive dependencies first\nUpdate direct dependencies\nVerify after each update

# Phase 2: Import Replacement
phase.incremental.2.title=Import Replacement
phase.incremental.2.description=Once your dependencies have been updated to use Jakarta EE, the next step is to systematically replace all javax.* imports with jakarta.* imports across your entire codebase. This is where the bulk of the work happens. Use your IDE's refactoring tools to perform safe, global replacements.
phase.incremental.2.steps=Replace transitive dependency imports\nReplace direct dependency imports\nReplace application code imports\nUpdate XML configuration files\nUpdate property files

# Phase 3: Testing & Verification
phase.incremental.3.title=Testing & Verification
phase.incremental.3.description=After completing the import replacements, comprehensive testing is essential to ensure everything works correctly. This phase involves running your full test suite to catch any issues that may have been introduced during the migration.
phase.incremental.3.steps=Run unit tests\nRun integration tests\nTest external system interactions\nTest database operations\nTest scheduled jobs and events

# Phase 4: Production Rollout
phase.incremental.4.title=Production Rollout
phase.incremental.4.description=The final phase involves deploying your migrated application to production. This requires careful planning and monitoring to ensure a smooth transition.
phase.incremental.4.steps=Deploy to staging environment\nMonitor performance metrics\nDeploy to production\nMonitor production closely\nHave rollback plan ready

# --- Transform Strategy Phases ---

# Phase 1: Build Tool Updates
phase.transform.1.title=Build Tool Updates
phase.transform.1.description=Update build configuration to use Jakarta EE dependencies. This involves modifying pom.xml or build.gradle files to use Jakarta EE compatible versions of your dependencies while maintaining javax compatibility for the initial phase.
phase.transform.1.steps=Add Jakarta EE BOM to dependencyManagement\nUpdate artifact coordinates\nConfigure Jakarta EE version\nVerify build compiles

# Phase 2: Runtime Transformation Setup
phase.transform.2.title=Runtime Transformation Setup
phase.transform.2.description=Configure runtime transformation for javax to jakarta conversion. This allows your application to work with both javax and jakarta simultaneously during the transition period. Options include Eclipse Transformer or custom class loading.
phase.transform.2.steps=Install Eclipse Transformer\nConfigure transformation rules\nTest transformation pipeline\nVerify runtime behavior

# Phase 3: Gradual Migration
phase.transform.3.title=Gradual Migration
phase.transform.3.description=Migrate code gradually while maintaining backward compatibility. Migrate one module at a time, testing thoroughly after each migration to ensure everything continues to work.
phase.transform.3.steps=Migrate lowest-risk module first\nTest module in isolation\nRepeat for each module\nVerify cross-module compatibility

# Phase 4: Complete Migration
phase.transform.4.title=Complete Migration
phase.transform.4.description=Complete the migration by removing runtime transformation. Once all code has been migrated to Jakarta EE, remove the transformation layer and deploy the fully migrated application.
phase.transform.4.steps=Remove transformation configuration\nVerify all tests pass\nDeploy fully migrated application

# --- Microservices Strategy Phases ---

# Phase 1: Service Inventory
phase.microservices.1.title=Service Inventory
phase.microservices.1.description=Create a comprehensive inventory of all microservices in your architecture. Identify each service, its dependencies, and the javax usage within each. This helps plan the migration order and understand inter-service dependencies.
phase.microservices.1.steps=List all microservices\nMap service dependencies\nIdentify javax usage per service\nPlan migration order

# Phase 2: Shared Libraries Migration
phase.microservices.2.title=Shared Libraries Migration
phase.microservices.2.description=Migrate shared libraries and common code first, before individual services. This ensures all services have access to the updated Jakarta EE versions of shared components.
phase.microservices.2.steps=Identify shared libraries\nMigrate shared code to Jakarta EE\nUpdate service dependencies\nVerify library compatibility

# Phase 3: Service-by-Service Migration
phase.microservices.3.title=Service-by-Service Migration
phase.microservices.3.description=Migrate each service individually, starting with the least critical services. Each service can use a different migration strategy based on its specific needs. Independent deployment and testing ensures minimal impact on the overall system.
phase.microservices.3.steps=Migrate least critical service first\nTest service in isolation\nUpdate service dependencies\nRepeat for remaining services

# Phase 4: Integration Testing
phase.microservices.4.title=Integration Testing
phase.microservices.4.description=After migrating individual services, perform comprehensive integration testing to ensure all services work correctly together. Test inter-service communication, data consistency, and overall system behavior.
phase.microservices.4.steps=Test inter-service communication\nVerify data consistency\nTest end-to-end scenarios\nDeploy to production

# --- Adapter Pattern Strategy Phases ---

# Phase 1: Adapter Interface Design
phase.adapter.1.title=Adapter Interface Design
phase.adapter.1.description=Design and create adapter interfaces that wrap javax functionality with jakarta implementations underneath. This allows your code to gradually migrate from javax to jakarta while maintaining the same external API.
phase.adapter.1.steps=Identify interfaces needing adapters\nDesign adapter interfaces\nCreate jakarta implementations\nTest adapter functionality

# Phase 2: Adapter Implementation
phase.adapter.2.title=Adapter Implementation
phase.adapter.2.description=Implement the adapter classes that translate between javax and jakarta. These adapters will be used internally while the external API remains unchanged.
phase.adapter.2.steps=Implement javax adapter wrapper\nImplement jakarta underlying classes\nConfigure adapter instantiation\nTest adapter integration

# Phase 3: Gradual Replacement
phase.adapter.3.title=Gradual Replacement
phase.adapter.3.description=Gradually replace usages of the adapter with direct jakarta calls. Start with the least critical paths and work towards more heavily used code.
phase.adapter.3.steps=Replace least critical usage first\nTest after each replacement\nProgress to more critical paths\nVerify performance impact

# Phase 4: Remove Adapters
phase.adapter.4.title=Remove Adapters
phase.adapter.4.description=Once all code has been migrated to use jakarta directly, remove the adapter layer and clean up any remaining javax dependencies.
phase.adapter.4.steps=Verify all jakarta usage\nRemove adapter layer\nClean up javax dependencies\nDeploy final version

# ============================================
# PREMIUM TAB DESCRIPTIONS
# ============================================

# Refactor Tab (Premium Placeholder)
premium.refactor.title=Refactor Tab
premium.refactor.description=Apply OpenRewrite recipes with one-click refactoring
premium.refactor.feature.1=One-click code refactoring
premium.refactor.feature.2=Automatic migration fixes

# Runtime Tab (Premium Placeholder)
premium.runtime.title=Runtime Tab
premium.runtime.description=Diagnose runtime errors with AI-powered analysis
premium.runtime.feature.1=Error pattern recognition
premium.runtime.feature.2=Automated remediation suggestions

# ============================================
# DIALOG MESSAGES
# ============================================

# Free Trial Dialog
dialog.trial.title=Start Free Trial
dialog.trial.message=Start a 7-day free trial of Premium features?\n\nPremium features include:\n• Auto-fixes for migration issues\n• One-click refactoring\n• Binary fixes for JAR files\n• Advanced dependency analysis
dialog.trial.success=Trial started! You now have 7 days of Premium access.\n\nPremium features are now available!

# Analysis Messages
dialog.analysis.complete=Analysis complete! {0} dependencies analyzed.
dialog.analysis.complete.noissues=Analysis complete. No Jakarta migration issues found.
dialog.analysis.failed=Cannot determine project path. Please open a project first.

# ============================================
# TOOLTIPS
# ============================================

# Toolbar Tooltips
tooltip.analyze=Run migration analysis on the current project
tooltip.refresh=Refresh analysis results
tooltip.upgrade=Get premium features: Auto-fixes, one-click refactoring, binary fixes
tooltip.trial=Start a 7-day free trial
tooltip.premium=Premium license active

# Strategy Card Tooltips
tooltip.strategy.big_bang=Migrate everything at once
tooltip.strategy.incremental=One dependency at a time
tooltip.strategy.transform=Combined build and runtime transformation
tooltip.strategy.microservices=Migrate each service independently
tooltip.strategy.adapter=Use adapter classes for javax/jakarta compatibility
